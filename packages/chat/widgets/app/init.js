/*
 * GitSense Chat - Minified Distribution File
 *
 * This JavaScript file is part of the minified distribution of GitSense Chat.
 * It has been optimized (minified) for performance and efficient delivery.
 *
 * This software is permitted for internal use and modification.
 * Copying for profit or redistribution is strictly not permitted.
 *
 * The Fair License, which formalizes these terms, will be adopted as the official license in the future.
 * Once finalized, the unminified source code will be freely available for internal use for non-
 * commercial purposes.
 *
 * This software may not be used to develop or enhance any product or service that competes
 * directly or indirectly with GitSense Chat without explicit permission.
 *
 * Copyright (c) 2025 GitSense. All rights reserved.
 */

let crypto=require("crypto"),path=require("path"),sleep=require("util").promisify(setTimeout),{existsSync,readFileSync,readdirSync,statSync}=require("fs"),{allAsync,runAsync,serializeAsync}=require("../app/sqlite.js"),Prompts=require("./prompts.js").Prompts,treesToJson=require("./components/chat-builder/utils/treesUtils.js").treesToJson,getDBPath=require("./db.js").getDBPath,DatabaseClient=require("@gitsense/gscb-db").DatabaseClient,{ChatManager,Logger}=require("@gitsense/gscb-git-tools"),OPTIONS_FILE=path.join(__dirname,"/../../../../chat.json"),p=new Prompts,models={},prompts={},providers={},trees=[];async function init(t){console.log("Initialize models"),await initModels(),console.log("Initialize prompts"),await initPrompts(t),console.log("Initialize providers"),await initProviders(t),console.log("Init trees"),treesToJson(path.join(__dirname,"components","chat-builder","trees"),!0).forEach(e=>trees.push(e)),console.log("Initalize repositories");var e,t=new Logger(!0),r={path:getDBPath(),poolSize:5,timeout:5e3},r=new DatabaseClient(r);try{await r.initialize(),t.log("Database initialized successfully");var i=await new ChatManager(r,null,"","","","branch",{},t).ensureGitReposChat();return t.log('"git-repos" chat exists with ID: '+i),i}catch(e){throw t.log('Failed to ensure "git-repos" chat exists: '+e.message),e}finally{r.isInitialized()&&(await r.close(),t.log("Database connection closed"))}for(e in providers){var s,n=providers[e].models;for(s in n)if(!models[s])throw new Error(`ERROR: No model name "${s}" for the provider "${e}" defined`)}}async function initModels(){var t=readOptionsFile().models;for(let e=0;e<t.length;e++){var{name:r,providers:i}=t[e];if(!r.match(/^---/)){let o=[];if(i.forEach((e,t)=>{var{name:e,modelId:r,maxTokens:i,prices:s,thinkingBudget:n,includeThoughts:a}=e;o.push({name:e.toLowerCase(),modelId:r,maxTokens:i,prices:s,thinkingBudget:n,includeThoughts:a})}),models[r])throw new Error(`ERROR: A model with the name "${r}" has already been defined`);models[r]={providers:o}}}}async function initProviders(t){var r=await(async()=>{let e="rate_limit",r=(e,e,{});return await serializeAsync(t,async()=>{await runAsync(t,"\n            CREATE TEMP TABLE rate_limit(\n                provider TEXT NOT NULL UNIQUE,\n                request_received_at INTEGER,\n                request_retry_after INTEGER,\n                request_ratelimit_limit_requests INTEGER,\n                request_ratelimit_limit_tokens INTEGER,\n                request_ratelimit_remaining_requests INTEGER,\n                request_ratelimit_remaining_tokens INTEGER,\n                request_ratelimit_reset_requests INTEGER,\n                request_ratelimit_reset_tokens INTEGER \n            );\n        "),await runAsync(t,"\n            INSERT OR IGNORE INTO rate_limit \n                SELECT \n                    provider,\n                    CAST(strftime('%s', request_received_at) AS INTEGER) AS request_received_at,\n                    CASE \n                        WHEN request_retry_after IS NULL THEN NULL\n                        ELSE CAST(strftime('%s', request_retry_after) AS INTEGER)\n                    END AS request_retry_after,\n                    request_ratelimit_limit_requests,\n                    request_ratelimit_limit_tokens,\n                    request_ratelimit_remaining_requests,\n                    request_ratelimit_remaining_tokens,\n                    CAST(strftime('%s', request_ratelimit_reset_requests) AS INTEGER) AS request_ratelimit_reset_requests,\n                    CAST(strftime('%s', request_ratelimit_reset_tokens) AS INTEGER) AS request_ratelimit_reset_tokens\n                FROM\n                    jobs\n                WHERE\n                    request_received_at IS NOT NULL AND\n                    request_received_at >= DATE(DATETIME('now'), '-3 day')\n                ORDER BY request_received_at DESC\n        "),(await allAsync(t,"SELECT * FROM "+e)).forEach(e=>{var t=e.provider;r[t]=e})}),r})(),i=readOptionsFile().providers;for(let e=0;e<i.length;e++){var{name:s,apiKeyName:n,baseURL:a,maxWorkers:o,maxConsecutiveFailures:l,minRemainingRequests:m,minRemainingTokens:u,waitBetweenRequests:p,waitBetweenServerError:d,waitBetweenSeriousError:c}=i[e],s=s.toLowerCase();if(providers[s])throw new Error(`ERROR: A provider with the name "${s}" has already been defined`);providers[s]={name:s,apiKeyName:n,baseURL:a,workers:0,consecutiveFailures:0,waitBetweenRequests:p,waitBetweenServerError:d,waitBetweenSeriousError:c,maxConsecutiveFailures:l,maxWorkers:o,minRemainingRequests:m,minRemainingTokens:u,rateLimit:r[s]||{}}}}async function initPrompts(r){var i=readOptionsFile().prompts,s=await p.map(r);i.unshift({id:-1,type:"system",name:"Ask Git",prompt:"Ask Git"}),i.unshift({id:0,type:"system",name:"No System Prompt"}),i.unshift({id:1,type:"system",name:"Custom System Prompt"});for(let t=0;t<i.length;t++){var{id:n=null,name:a,type:o="system",file:l,prompt:m}=i[t];if(prompts[a])throw new Error(`ERROR: A prompt with the name "${a}" has already been defined`);l=null===n?path.join(__dirname,"prompts",l):null;let e=null;try{e=m||(null===l?"":readFileSync(l,"utf-8").trim())}catch(e){throw new Error(`ERROR: Failed to read prompt file ${l}: `+e)}l=null===n||m?p.computeHash(o,a,e):n;s[l]||(console.log(`Inserting ${o} prompt named "${a}"`),promptId=await p.insert(r,n,o,l,a,e),console.log("Successfully inserted with id "+n),s[l]={id:promptId,hash:l,type:o,name:a}),prompts[a]=s[l]}}function readOptionsFile(){if(!existsSync(OPTIONS_FILE))return console.warn("No options file found at "+OPTIONS_FILE),null;var e=readFileSync(OPTIONS_FILE,"utf8");try{return JSON.parse(e)}catch(e){throw new Error(`ERROR: Invalid JSON file ${OPTIONS_FILE}:
`+e)}}module.exports={init:init,models:models,prompts:prompts,providers:providers,trees:trees,readOptionsFile:readOptionsFile};
